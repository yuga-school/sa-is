# SA-IS Visualization Tool

## 概要 (Overview)

本プロジェクトは、線形時間でのSuffix Array構築を可能にする画期的なアルゴリズム、**SA-IS (Suffix Array - Induced Sorting)** の複雑な動作原理を、ステップバイステップで視覚的に学習するためのWebアプリケーションです。

ユーザーは文字列を入力するだけで、SA-ISがどのようにして सफिक्सを分類し、誘導ソートを行い、再帰的に問題を解決していくのかを、インタラクティブに追体験できます。

 
*(ここにアプリケーションのスクリーンショット画像を挿入してください)*

## 主な特徴 (Features)

*   **ステップバイステップ実行:** 「Next」「Prev」「Auto」ボタンにより、アルゴリズムの各ステップを自分のペースで追跡可能。
*   **動的な可視化:**
    *   **文字列ビュー:** 各文字のL/S/LMSタイプをリアルタイムで色分け表示。
    *   **SAビュー:** 誘導ソートの過程で、バケットに सफिक्सが配置されていく様子を忠実に再現。
*   **再帰処理の可視化:**
    *   再帰に入る際、メインの表示エリア全体が再帰レベルの問題に切り替わり、ユーザーは常に「今解いている問題」に集中できます。
    *   多段再帰（レベル2以上）にも完全対応。
*   **インタラクティブな解説:** 各ステップで、現在行われている処理の概要を平易な言葉で説明。

## 技術的アーキテクチャ (Technical Architecture)

本アプリケーションは、外部ライブラリへの依存を最小限に抑え、アルゴリズムのロジックを明確に保つことを重視しています。

*   **言語:** Vanilla JavaScript (ES6+)
*   **スタイリング:** Tailwind CSS
*   **コアロジック:**
    *   **`Generator`関数:** SA-ISアルゴリズム本体を`function*`で実装。各ステップの計算が終わるたびに、`yield`キーワードで処理を中断し、その時点でのアプリケーションの状態（`S`, `SA`, `type`, ハイライト情報など）をUI側に渡します。
    *   **状態管理:** `history`配列に`yield`された全状態を記録することで、「Prev」機能を実現。UIは常に`history[currentStepIndex]`を描画するだけのシンプルな構造を保ちます。

## 開発メモ：直面した課題とその解決策

このアプリケーションの開発は、SA-ISアルゴリズムの深い理解を要求される挑戦的なプロセスでした。以下に主要な課題とその解決策を記録します。

### 1. 誘導ソートの正しい可視化

*   **初期の誤り:** 当初、SA（Suffix Array）の「値」に基づいて表示をグループ化しており、誘導ソートの核心である「バケット」の概念が全く表現できていませんでした。
*   **解決策:** `getBuckets`関数で計算したバケット情報（開始位置、サイズ）を元に、文字ごとの「バケット行」をUIに描画。SA配列の「インデックス」に対応するスロットに値を配置する方式に変更し、`-1`（未配置）の状態を明確に可視化しました。

### 2. 再帰処理の可視化戦略

*   **試み①：ネストコンテナ方式:** 再帰のたびにUIをネストさせる案。しかし、データ管理が複雑化し、UIが煩雑になるため破棄。
*   **試み②：画面全体置き換え方式:** SA-ISの再帰は常に「幅が1」である特性を活かし、再帰に入るたびに表示エリア全体を再帰問題のUIで置き換える方式を採用。これにより、ユーザーは常に単一の問題に集中できます。
*   **実装の鍵:**
    *   `renderStateStack`: 親レベルの状態（の履歴インデックス）を保存するスタック。
    *   **境界状態の導入:** `Generator`が再帰の開始(`isRecursionStart`)と終了(`isRecursionEnd`)を伝える特別な状態を`yield`。UI側はこれをトリガーとして、スタック操作や画面の切り替えを行います。

### 3. 多段再帰における状態遷移ロジックのバグ

*   **現象:** 1段階の再帰は動作するものの、2段階以上の再帰で「Next」が無限ループに陥ったり、「Prev」で状態が破壊される問題が発生。
*   **原因:** `nextStep`関数が、再帰終了時に履歴ポインタ(`currentStepIndex`)を過去に戻していたこと。
*   **解決策:**
    *   `currentStepIndex`は常に前進するだけ、という大原則を徹底。
    *   `nextStep`は単純に次の状態を描画するだけ。
    *   `prevStep`は、境界状態を検知してスタックを操作し、レベル間を安全に移動するロジックに修正。

### 4. アルゴリズムの核心理解の深化

開発を通じて、SA-ISの再帰の「目的」についての理解が深まりました。

*   **誤解:** 「高コストな文字列比較を、低コストな整数比較の問題に変換する」
*   **本質:** 「LMS-substringに**重複**があり順序が一意に決まらない場合に、その相対順序を決定するため、**同じ構造を持つより小さな問題（S'のSA構築）**に再帰的に委ねる」

この本質的な理解は、アプリケーション内の解説テキストや、今後の機能改善における指針となっています。

## セットアップと実行 (Setup and Usage)

1.  このリポジトリをクローンします。
    ```bash
    git clone https://github.com/your-username/sais-visualizer.git
    ```
2.  `index.html`ファイルをブラウザで直接開くだけで動作します。ローカルサーバーは不要です。
3.  入力フィールドに、末尾に`$`を付けた文字列（例: `banana$`, `tobeornottobe$`）を入力し、「可視化開始」ボタンをクリックしてください。

## 今後の課題 (Future Work)

*   UI/UXの改善（パンくずリストによる現在の再帰深度の表示など）。
*   各ステップの解説文を、最新のアルゴリズム理解に基づいて全面的に見直す。
*   コードのリファクタリングと、より詳細なコメントの追加。
*   ユニットテストの導入。

## ライセンス (License)

This project is licensed under the MIT License.
